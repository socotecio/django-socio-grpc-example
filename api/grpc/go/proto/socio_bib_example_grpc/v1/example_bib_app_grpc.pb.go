// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/socio_bib_example_grpc/v1/example_bib_app.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthorController_Create_FullMethodName        = "/dsg_example.example_bib_app.AuthorController/Create"
	AuthorController_Destroy_FullMethodName       = "/dsg_example.example_bib_app.AuthorController/Destroy"
	AuthorController_List_FullMethodName          = "/dsg_example.example_bib_app.AuthorController/List"
	AuthorController_PartialUpdate_FullMethodName = "/dsg_example.example_bib_app.AuthorController/PartialUpdate"
	AuthorController_Retrieve_FullMethodName      = "/dsg_example.example_bib_app.AuthorController/Retrieve"
	AuthorController_Update_FullMethodName        = "/dsg_example.example_bib_app.AuthorController/Update"
)

// AuthorControllerClient is the client API for AuthorController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorControllerClient interface {
	Create(ctx context.Context, in *AuthorRequest, opts ...grpc.CallOption) (*AuthorResponse, error)
	Destroy(ctx context.Context, in *AuthorDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *AuthorListRequest, opts ...grpc.CallOption) (*AuthorListResponse, error)
	PartialUpdate(ctx context.Context, in *AuthorPartialUpdateRequest, opts ...grpc.CallOption) (*AuthorResponse, error)
	Retrieve(ctx context.Context, in *AuthorRetrieveRequest, opts ...grpc.CallOption) (*AuthorResponse, error)
	Update(ctx context.Context, in *AuthorRequest, opts ...grpc.CallOption) (*AuthorResponse, error)
}

type authorControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorControllerClient(cc grpc.ClientConnInterface) AuthorControllerClient {
	return &authorControllerClient{cc}
}

func (c *authorControllerClient) Create(ctx context.Context, in *AuthorRequest, opts ...grpc.CallOption) (*AuthorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorResponse)
	err := c.cc.Invoke(ctx, AuthorController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorControllerClient) Destroy(ctx context.Context, in *AuthorDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthorController_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorControllerClient) List(ctx context.Context, in *AuthorListRequest, opts ...grpc.CallOption) (*AuthorListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorListResponse)
	err := c.cc.Invoke(ctx, AuthorController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorControllerClient) PartialUpdate(ctx context.Context, in *AuthorPartialUpdateRequest, opts ...grpc.CallOption) (*AuthorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorResponse)
	err := c.cc.Invoke(ctx, AuthorController_PartialUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorControllerClient) Retrieve(ctx context.Context, in *AuthorRetrieveRequest, opts ...grpc.CallOption) (*AuthorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorResponse)
	err := c.cc.Invoke(ctx, AuthorController_Retrieve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorControllerClient) Update(ctx context.Context, in *AuthorRequest, opts ...grpc.CallOption) (*AuthorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorResponse)
	err := c.cc.Invoke(ctx, AuthorController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorControllerServer is the server API for AuthorController service.
// All implementations must embed UnimplementedAuthorControllerServer
// for forward compatibility.
type AuthorControllerServer interface {
	Create(context.Context, *AuthorRequest) (*AuthorResponse, error)
	Destroy(context.Context, *AuthorDestroyRequest) (*emptypb.Empty, error)
	List(context.Context, *AuthorListRequest) (*AuthorListResponse, error)
	PartialUpdate(context.Context, *AuthorPartialUpdateRequest) (*AuthorResponse, error)
	Retrieve(context.Context, *AuthorRetrieveRequest) (*AuthorResponse, error)
	Update(context.Context, *AuthorRequest) (*AuthorResponse, error)
	mustEmbedUnimplementedAuthorControllerServer()
}

// UnimplementedAuthorControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthorControllerServer struct{}

func (UnimplementedAuthorControllerServer) Create(context.Context, *AuthorRequest) (*AuthorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAuthorControllerServer) Destroy(context.Context, *AuthorDestroyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedAuthorControllerServer) List(context.Context, *AuthorListRequest) (*AuthorListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAuthorControllerServer) PartialUpdate(context.Context, *AuthorPartialUpdateRequest) (*AuthorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialUpdate not implemented")
}
func (UnimplementedAuthorControllerServer) Retrieve(context.Context, *AuthorRetrieveRequest) (*AuthorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedAuthorControllerServer) Update(context.Context, *AuthorRequest) (*AuthorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAuthorControllerServer) mustEmbedUnimplementedAuthorControllerServer() {}
func (UnimplementedAuthorControllerServer) testEmbeddedByValue()                          {}

// UnsafeAuthorControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorControllerServer will
// result in compilation errors.
type UnsafeAuthorControllerServer interface {
	mustEmbedUnimplementedAuthorControllerServer()
}

func RegisterAuthorControllerServer(s grpc.ServiceRegistrar, srv AuthorControllerServer) {
	// If the following call pancis, it indicates UnimplementedAuthorControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthorController_ServiceDesc, srv)
}

func _AuthorController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).Create(ctx, req.(*AuthorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorController_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorDestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).Destroy(ctx, req.(*AuthorDestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).List(ctx, req.(*AuthorListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorController_PartialUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorPartialUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).PartialUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_PartialUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).PartialUpdate(ctx, req.(*AuthorPartialUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorController_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_Retrieve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).Retrieve(ctx, req.(*AuthorRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorControllerServer).Update(ctx, req.(*AuthorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthorController_ServiceDesc is the grpc.ServiceDesc for AuthorController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthorController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dsg_example.example_bib_app.AuthorController",
	HandlerType: (*AuthorControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AuthorController_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _AuthorController_Destroy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AuthorController_List_Handler,
		},
		{
			MethodName: "PartialUpdate",
			Handler:    _AuthorController_PartialUpdate_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _AuthorController_Retrieve_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AuthorController_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/socio_bib_example_grpc/v1/example_bib_app.proto",
}

const (
	BookController_Create_FullMethodName              = "/dsg_example.example_bib_app.BookController/Create"
	BookController_Destroy_FullMethodName             = "/dsg_example.example_bib_app.BookController/Destroy"
	BookController_List_FullMethodName                = "/dsg_example.example_bib_app.BookController/List"
	BookController_PartialUpdate_FullMethodName       = "/dsg_example.example_bib_app.BookController/PartialUpdate"
	BookController_Retrieve_FullMethodName            = "/dsg_example.example_bib_app.BookController/Retrieve"
	BookController_Stream_FullMethodName              = "/dsg_example.example_bib_app.BookController/Stream"
	BookController_StreamBooksByIDList_FullMethodName = "/dsg_example.example_bib_app.BookController/StreamBooksByIDList"
	BookController_Update_FullMethodName              = "/dsg_example.example_bib_app.BookController/Update"
)

// BookControllerClient is the client API for BookController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BookControllerClient interface {
	Create(ctx context.Context, in *BookRequest, opts ...grpc.CallOption) (*BookResponse, error)
	Destroy(ctx context.Context, in *BookDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *BookListRequest, opts ...grpc.CallOption) (*BookListResponse, error)
	PartialUpdate(ctx context.Context, in *BookPartialUpdateRequest, opts ...grpc.CallOption) (*BookResponse, error)
	Retrieve(ctx context.Context, in *BookRetrieveRequest, opts ...grpc.CallOption) (*BookResponse, error)
	Stream(ctx context.Context, in *BookStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BookResponse], error)
	StreamBooksByIDList(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse], error)
	Update(ctx context.Context, in *BookRequest, opts ...grpc.CallOption) (*BookResponse, error)
}

type bookControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewBookControllerClient(cc grpc.ClientConnInterface) BookControllerClient {
	return &bookControllerClient{cc}
}

func (c *bookControllerClient) Create(ctx context.Context, in *BookRequest, opts ...grpc.CallOption) (*BookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookResponse)
	err := c.cc.Invoke(ctx, BookController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookControllerClient) Destroy(ctx context.Context, in *BookDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BookController_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookControllerClient) List(ctx context.Context, in *BookListRequest, opts ...grpc.CallOption) (*BookListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookListResponse)
	err := c.cc.Invoke(ctx, BookController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookControllerClient) PartialUpdate(ctx context.Context, in *BookPartialUpdateRequest, opts ...grpc.CallOption) (*BookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookResponse)
	err := c.cc.Invoke(ctx, BookController_PartialUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookControllerClient) Retrieve(ctx context.Context, in *BookRetrieveRequest, opts ...grpc.CallOption) (*BookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookResponse)
	err := c.cc.Invoke(ctx, BookController_Retrieve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookControllerClient) Stream(ctx context.Context, in *BookStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BookResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BookController_ServiceDesc.Streams[0], BookController_Stream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BookStreamRequest, BookResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BookController_StreamClient = grpc.ServerStreamingClient[BookResponse]

func (c *bookControllerClient) StreamBooksByIDList(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BookController_ServiceDesc.Streams[1], BookController_StreamBooksByIDList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BookController_StreamBooksByIDListClient = grpc.BidiStreamingClient[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]

func (c *bookControllerClient) Update(ctx context.Context, in *BookRequest, opts ...grpc.CallOption) (*BookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookResponse)
	err := c.cc.Invoke(ctx, BookController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BookControllerServer is the server API for BookController service.
// All implementations must embed UnimplementedBookControllerServer
// for forward compatibility.
type BookControllerServer interface {
	Create(context.Context, *BookRequest) (*BookResponse, error)
	Destroy(context.Context, *BookDestroyRequest) (*emptypb.Empty, error)
	List(context.Context, *BookListRequest) (*BookListResponse, error)
	PartialUpdate(context.Context, *BookPartialUpdateRequest) (*BookResponse, error)
	Retrieve(context.Context, *BookRetrieveRequest) (*BookResponse, error)
	Stream(*BookStreamRequest, grpc.ServerStreamingServer[BookResponse]) error
	StreamBooksByIDList(grpc.BidiStreamingServer[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]) error
	Update(context.Context, *BookRequest) (*BookResponse, error)
	mustEmbedUnimplementedBookControllerServer()
}

// UnimplementedBookControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBookControllerServer struct{}

func (UnimplementedBookControllerServer) Create(context.Context, *BookRequest) (*BookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedBookControllerServer) Destroy(context.Context, *BookDestroyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedBookControllerServer) List(context.Context, *BookListRequest) (*BookListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedBookControllerServer) PartialUpdate(context.Context, *BookPartialUpdateRequest) (*BookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialUpdate not implemented")
}
func (UnimplementedBookControllerServer) Retrieve(context.Context, *BookRetrieveRequest) (*BookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedBookControllerServer) Stream(*BookStreamRequest, grpc.ServerStreamingServer[BookResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedBookControllerServer) StreamBooksByIDList(grpc.BidiStreamingServer[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamBooksByIDList not implemented")
}
func (UnimplementedBookControllerServer) Update(context.Context, *BookRequest) (*BookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedBookControllerServer) mustEmbedUnimplementedBookControllerServer() {}
func (UnimplementedBookControllerServer) testEmbeddedByValue()                        {}

// UnsafeBookControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BookControllerServer will
// result in compilation errors.
type UnsafeBookControllerServer interface {
	mustEmbedUnimplementedBookControllerServer()
}

func RegisterBookControllerServer(s grpc.ServiceRegistrar, srv BookControllerServer) {
	// If the following call pancis, it indicates UnimplementedBookControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BookController_ServiceDesc, srv)
}

func _BookController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).Create(ctx, req.(*BookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookController_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookDestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).Destroy(ctx, req.(*BookDestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).List(ctx, req.(*BookListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookController_PartialUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookPartialUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).PartialUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_PartialUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).PartialUpdate(ctx, req.(*BookPartialUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookController_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_Retrieve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).Retrieve(ctx, req.(*BookRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookController_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BookStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BookControllerServer).Stream(m, &grpc.GenericServerStream[BookStreamRequest, BookResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BookController_StreamServer = grpc.ServerStreamingServer[BookResponse]

func _BookController_StreamBooksByIDList_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BookControllerServer).StreamBooksByIDList(&grpc.GenericServerStream[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BookController_StreamBooksByIDListServer = grpc.BidiStreamingServer[BookStreamBooksByIDListRequest, BookStreamBooksByIDListResponse]

func _BookController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookControllerServer).Update(ctx, req.(*BookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BookController_ServiceDesc is the grpc.ServiceDesc for BookController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BookController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dsg_example.example_bib_app.BookController",
	HandlerType: (*BookControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _BookController_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _BookController_Destroy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _BookController_List_Handler,
		},
		{
			MethodName: "PartialUpdate",
			Handler:    _BookController_PartialUpdate_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _BookController_Retrieve_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _BookController_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _BookController_Stream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBooksByIDList",
			Handler:       _BookController_StreamBooksByIDList_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/socio_bib_example_grpc/v1/example_bib_app.proto",
}

const (
	JournalController_Create_FullMethodName        = "/dsg_example.example_bib_app.JournalController/Create"
	JournalController_Destroy_FullMethodName       = "/dsg_example.example_bib_app.JournalController/Destroy"
	JournalController_List_FullMethodName          = "/dsg_example.example_bib_app.JournalController/List"
	JournalController_PartialUpdate_FullMethodName = "/dsg_example.example_bib_app.JournalController/PartialUpdate"
	JournalController_Retrieve_FullMethodName      = "/dsg_example.example_bib_app.JournalController/Retrieve"
	JournalController_Update_FullMethodName        = "/dsg_example.example_bib_app.JournalController/Update"
)

// JournalControllerClient is the client API for JournalController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JournalControllerClient interface {
	Create(ctx context.Context, in *JournalRequest, opts ...grpc.CallOption) (*JournalResponse, error)
	Destroy(ctx context.Context, in *JournalDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *JournalListRequest, opts ...grpc.CallOption) (*JournalListResponse, error)
	PartialUpdate(ctx context.Context, in *JournalPartialUpdateRequest, opts ...grpc.CallOption) (*JournalResponse, error)
	Retrieve(ctx context.Context, in *JournalRetrieveRequest, opts ...grpc.CallOption) (*JournalResponse, error)
	Update(ctx context.Context, in *JournalRequest, opts ...grpc.CallOption) (*JournalResponse, error)
}

type journalControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewJournalControllerClient(cc grpc.ClientConnInterface) JournalControllerClient {
	return &journalControllerClient{cc}
}

func (c *journalControllerClient) Create(ctx context.Context, in *JournalRequest, opts ...grpc.CallOption) (*JournalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalResponse)
	err := c.cc.Invoke(ctx, JournalController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalControllerClient) Destroy(ctx context.Context, in *JournalDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, JournalController_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalControllerClient) List(ctx context.Context, in *JournalListRequest, opts ...grpc.CallOption) (*JournalListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalListResponse)
	err := c.cc.Invoke(ctx, JournalController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalControllerClient) PartialUpdate(ctx context.Context, in *JournalPartialUpdateRequest, opts ...grpc.CallOption) (*JournalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalResponse)
	err := c.cc.Invoke(ctx, JournalController_PartialUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalControllerClient) Retrieve(ctx context.Context, in *JournalRetrieveRequest, opts ...grpc.CallOption) (*JournalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalResponse)
	err := c.cc.Invoke(ctx, JournalController_Retrieve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalControllerClient) Update(ctx context.Context, in *JournalRequest, opts ...grpc.CallOption) (*JournalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalResponse)
	err := c.cc.Invoke(ctx, JournalController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JournalControllerServer is the server API for JournalController service.
// All implementations must embed UnimplementedJournalControllerServer
// for forward compatibility.
type JournalControllerServer interface {
	Create(context.Context, *JournalRequest) (*JournalResponse, error)
	Destroy(context.Context, *JournalDestroyRequest) (*emptypb.Empty, error)
	List(context.Context, *JournalListRequest) (*JournalListResponse, error)
	PartialUpdate(context.Context, *JournalPartialUpdateRequest) (*JournalResponse, error)
	Retrieve(context.Context, *JournalRetrieveRequest) (*JournalResponse, error)
	Update(context.Context, *JournalRequest) (*JournalResponse, error)
	mustEmbedUnimplementedJournalControllerServer()
}

// UnimplementedJournalControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJournalControllerServer struct{}

func (UnimplementedJournalControllerServer) Create(context.Context, *JournalRequest) (*JournalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedJournalControllerServer) Destroy(context.Context, *JournalDestroyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedJournalControllerServer) List(context.Context, *JournalListRequest) (*JournalListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedJournalControllerServer) PartialUpdate(context.Context, *JournalPartialUpdateRequest) (*JournalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialUpdate not implemented")
}
func (UnimplementedJournalControllerServer) Retrieve(context.Context, *JournalRetrieveRequest) (*JournalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedJournalControllerServer) Update(context.Context, *JournalRequest) (*JournalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedJournalControllerServer) mustEmbedUnimplementedJournalControllerServer() {}
func (UnimplementedJournalControllerServer) testEmbeddedByValue()                           {}

// UnsafeJournalControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JournalControllerServer will
// result in compilation errors.
type UnsafeJournalControllerServer interface {
	mustEmbedUnimplementedJournalControllerServer()
}

func RegisterJournalControllerServer(s grpc.ServiceRegistrar, srv JournalControllerServer) {
	// If the following call pancis, it indicates UnimplementedJournalControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JournalController_ServiceDesc, srv)
}

func _JournalController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).Create(ctx, req.(*JournalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JournalController_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalDestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).Destroy(ctx, req.(*JournalDestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JournalController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).List(ctx, req.(*JournalListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JournalController_PartialUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalPartialUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).PartialUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_PartialUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).PartialUpdate(ctx, req.(*JournalPartialUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JournalController_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_Retrieve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).Retrieve(ctx, req.(*JournalRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JournalController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JournalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JournalController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalControllerServer).Update(ctx, req.(*JournalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JournalController_ServiceDesc is the grpc.ServiceDesc for JournalController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JournalController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dsg_example.example_bib_app.JournalController",
	HandlerType: (*JournalControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _JournalController_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _JournalController_Destroy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _JournalController_List_Handler,
		},
		{
			MethodName: "PartialUpdate",
			Handler:    _JournalController_PartialUpdate_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _JournalController_Retrieve_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _JournalController_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/socio_bib_example_grpc/v1/example_bib_app.proto",
}

const (
	PublicationCategoryController_Create_FullMethodName        = "/dsg_example.example_bib_app.PublicationCategoryController/Create"
	PublicationCategoryController_Destroy_FullMethodName       = "/dsg_example.example_bib_app.PublicationCategoryController/Destroy"
	PublicationCategoryController_List_FullMethodName          = "/dsg_example.example_bib_app.PublicationCategoryController/List"
	PublicationCategoryController_PartialUpdate_FullMethodName = "/dsg_example.example_bib_app.PublicationCategoryController/PartialUpdate"
	PublicationCategoryController_Retrieve_FullMethodName      = "/dsg_example.example_bib_app.PublicationCategoryController/Retrieve"
	PublicationCategoryController_Update_FullMethodName        = "/dsg_example.example_bib_app.PublicationCategoryController/Update"
)

// PublicationCategoryControllerClient is the client API for PublicationCategoryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicationCategoryControllerClient interface {
	Create(ctx context.Context, in *PublicationCategoryRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error)
	Destroy(ctx context.Context, in *PublicationCategoryDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *PublicationCategoryListRequest, opts ...grpc.CallOption) (*PublicationCategoryListResponse, error)
	PartialUpdate(ctx context.Context, in *PublicationCategoryPartialUpdateRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error)
	Retrieve(ctx context.Context, in *PublicationCategoryRetrieveRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error)
	Update(ctx context.Context, in *PublicationCategoryRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error)
}

type publicationCategoryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicationCategoryControllerClient(cc grpc.ClientConnInterface) PublicationCategoryControllerClient {
	return &publicationCategoryControllerClient{cc}
}

func (c *publicationCategoryControllerClient) Create(ctx context.Context, in *PublicationCategoryRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicationCategoryResponse)
	err := c.cc.Invoke(ctx, PublicationCategoryController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicationCategoryControllerClient) Destroy(ctx context.Context, in *PublicationCategoryDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PublicationCategoryController_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicationCategoryControllerClient) List(ctx context.Context, in *PublicationCategoryListRequest, opts ...grpc.CallOption) (*PublicationCategoryListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicationCategoryListResponse)
	err := c.cc.Invoke(ctx, PublicationCategoryController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicationCategoryControllerClient) PartialUpdate(ctx context.Context, in *PublicationCategoryPartialUpdateRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicationCategoryResponse)
	err := c.cc.Invoke(ctx, PublicationCategoryController_PartialUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicationCategoryControllerClient) Retrieve(ctx context.Context, in *PublicationCategoryRetrieveRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicationCategoryResponse)
	err := c.cc.Invoke(ctx, PublicationCategoryController_Retrieve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicationCategoryControllerClient) Update(ctx context.Context, in *PublicationCategoryRequest, opts ...grpc.CallOption) (*PublicationCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicationCategoryResponse)
	err := c.cc.Invoke(ctx, PublicationCategoryController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicationCategoryControllerServer is the server API for PublicationCategoryController service.
// All implementations must embed UnimplementedPublicationCategoryControllerServer
// for forward compatibility.
type PublicationCategoryControllerServer interface {
	Create(context.Context, *PublicationCategoryRequest) (*PublicationCategoryResponse, error)
	Destroy(context.Context, *PublicationCategoryDestroyRequest) (*emptypb.Empty, error)
	List(context.Context, *PublicationCategoryListRequest) (*PublicationCategoryListResponse, error)
	PartialUpdate(context.Context, *PublicationCategoryPartialUpdateRequest) (*PublicationCategoryResponse, error)
	Retrieve(context.Context, *PublicationCategoryRetrieveRequest) (*PublicationCategoryResponse, error)
	Update(context.Context, *PublicationCategoryRequest) (*PublicationCategoryResponse, error)
	mustEmbedUnimplementedPublicationCategoryControllerServer()
}

// UnimplementedPublicationCategoryControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPublicationCategoryControllerServer struct{}

func (UnimplementedPublicationCategoryControllerServer) Create(context.Context, *PublicationCategoryRequest) (*PublicationCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) Destroy(context.Context, *PublicationCategoryDestroyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) List(context.Context, *PublicationCategoryListRequest) (*PublicationCategoryListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) PartialUpdate(context.Context, *PublicationCategoryPartialUpdateRequest) (*PublicationCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialUpdate not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) Retrieve(context.Context, *PublicationCategoryRetrieveRequest) (*PublicationCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) Update(context.Context, *PublicationCategoryRequest) (*PublicationCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPublicationCategoryControllerServer) mustEmbedUnimplementedPublicationCategoryControllerServer() {
}
func (UnimplementedPublicationCategoryControllerServer) testEmbeddedByValue() {}

// UnsafePublicationCategoryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicationCategoryControllerServer will
// result in compilation errors.
type UnsafePublicationCategoryControllerServer interface {
	mustEmbedUnimplementedPublicationCategoryControllerServer()
}

func RegisterPublicationCategoryControllerServer(s grpc.ServiceRegistrar, srv PublicationCategoryControllerServer) {
	// If the following call pancis, it indicates UnimplementedPublicationCategoryControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PublicationCategoryController_ServiceDesc, srv)
}

func _PublicationCategoryController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).Create(ctx, req.(*PublicationCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicationCategoryController_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryDestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).Destroy(ctx, req.(*PublicationCategoryDestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicationCategoryController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).List(ctx, req.(*PublicationCategoryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicationCategoryController_PartialUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryPartialUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).PartialUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_PartialUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).PartialUpdate(ctx, req.(*PublicationCategoryPartialUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicationCategoryController_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_Retrieve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).Retrieve(ctx, req.(*PublicationCategoryRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicationCategoryController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicationCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicationCategoryControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicationCategoryController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicationCategoryControllerServer).Update(ctx, req.(*PublicationCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublicationCategoryController_ServiceDesc is the grpc.ServiceDesc for PublicationCategoryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublicationCategoryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dsg_example.example_bib_app.PublicationCategoryController",
	HandlerType: (*PublicationCategoryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PublicationCategoryController_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _PublicationCategoryController_Destroy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PublicationCategoryController_List_Handler,
		},
		{
			MethodName: "PartialUpdate",
			Handler:    _PublicationCategoryController_PartialUpdate_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _PublicationCategoryController_Retrieve_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PublicationCategoryController_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/socio_bib_example_grpc/v1/example_bib_app.proto",
}

const (
	PublisherController_Create_FullMethodName        = "/dsg_example.example_bib_app.PublisherController/Create"
	PublisherController_Destroy_FullMethodName       = "/dsg_example.example_bib_app.PublisherController/Destroy"
	PublisherController_List_FullMethodName          = "/dsg_example.example_bib_app.PublisherController/List"
	PublisherController_PartialUpdate_FullMethodName = "/dsg_example.example_bib_app.PublisherController/PartialUpdate"
	PublisherController_Retrieve_FullMethodName      = "/dsg_example.example_bib_app.PublisherController/Retrieve"
	PublisherController_Update_FullMethodName        = "/dsg_example.example_bib_app.PublisherController/Update"
)

// PublisherControllerClient is the client API for PublisherController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublisherControllerClient interface {
	Create(ctx context.Context, in *PublisherRequest, opts ...grpc.CallOption) (*PublisherResponse, error)
	Destroy(ctx context.Context, in *PublisherDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *PublisherListRequest, opts ...grpc.CallOption) (*PublisherListResponse, error)
	PartialUpdate(ctx context.Context, in *PublisherPartialUpdateRequest, opts ...grpc.CallOption) (*PublisherResponse, error)
	Retrieve(ctx context.Context, in *PublisherRetrieveRequest, opts ...grpc.CallOption) (*PublisherResponse, error)
	Update(ctx context.Context, in *PublisherRequest, opts ...grpc.CallOption) (*PublisherResponse, error)
}

type publisherControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewPublisherControllerClient(cc grpc.ClientConnInterface) PublisherControllerClient {
	return &publisherControllerClient{cc}
}

func (c *publisherControllerClient) Create(ctx context.Context, in *PublisherRequest, opts ...grpc.CallOption) (*PublisherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublisherResponse)
	err := c.cc.Invoke(ctx, PublisherController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherControllerClient) Destroy(ctx context.Context, in *PublisherDestroyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PublisherController_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherControllerClient) List(ctx context.Context, in *PublisherListRequest, opts ...grpc.CallOption) (*PublisherListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublisherListResponse)
	err := c.cc.Invoke(ctx, PublisherController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherControllerClient) PartialUpdate(ctx context.Context, in *PublisherPartialUpdateRequest, opts ...grpc.CallOption) (*PublisherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublisherResponse)
	err := c.cc.Invoke(ctx, PublisherController_PartialUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherControllerClient) Retrieve(ctx context.Context, in *PublisherRetrieveRequest, opts ...grpc.CallOption) (*PublisherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublisherResponse)
	err := c.cc.Invoke(ctx, PublisherController_Retrieve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherControllerClient) Update(ctx context.Context, in *PublisherRequest, opts ...grpc.CallOption) (*PublisherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublisherResponse)
	err := c.cc.Invoke(ctx, PublisherController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublisherControllerServer is the server API for PublisherController service.
// All implementations must embed UnimplementedPublisherControllerServer
// for forward compatibility.
type PublisherControllerServer interface {
	Create(context.Context, *PublisherRequest) (*PublisherResponse, error)
	Destroy(context.Context, *PublisherDestroyRequest) (*emptypb.Empty, error)
	List(context.Context, *PublisherListRequest) (*PublisherListResponse, error)
	PartialUpdate(context.Context, *PublisherPartialUpdateRequest) (*PublisherResponse, error)
	Retrieve(context.Context, *PublisherRetrieveRequest) (*PublisherResponse, error)
	Update(context.Context, *PublisherRequest) (*PublisherResponse, error)
	mustEmbedUnimplementedPublisherControllerServer()
}

// UnimplementedPublisherControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPublisherControllerServer struct{}

func (UnimplementedPublisherControllerServer) Create(context.Context, *PublisherRequest) (*PublisherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPublisherControllerServer) Destroy(context.Context, *PublisherDestroyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedPublisherControllerServer) List(context.Context, *PublisherListRequest) (*PublisherListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPublisherControllerServer) PartialUpdate(context.Context, *PublisherPartialUpdateRequest) (*PublisherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialUpdate not implemented")
}
func (UnimplementedPublisherControllerServer) Retrieve(context.Context, *PublisherRetrieveRequest) (*PublisherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedPublisherControllerServer) Update(context.Context, *PublisherRequest) (*PublisherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPublisherControllerServer) mustEmbedUnimplementedPublisherControllerServer() {}
func (UnimplementedPublisherControllerServer) testEmbeddedByValue()                             {}

// UnsafePublisherControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublisherControllerServer will
// result in compilation errors.
type UnsafePublisherControllerServer interface {
	mustEmbedUnimplementedPublisherControllerServer()
}

func RegisterPublisherControllerServer(s grpc.ServiceRegistrar, srv PublisherControllerServer) {
	// If the following call pancis, it indicates UnimplementedPublisherControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PublisherController_ServiceDesc, srv)
}

func _PublisherController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).Create(ctx, req.(*PublisherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublisherController_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherDestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).Destroy(ctx, req.(*PublisherDestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublisherController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).List(ctx, req.(*PublisherListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublisherController_PartialUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherPartialUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).PartialUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_PartialUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).PartialUpdate(ctx, req.(*PublisherPartialUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublisherController_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherRetrieveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_Retrieve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).Retrieve(ctx, req.(*PublisherRetrieveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublisherController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublisherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublisherController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherControllerServer).Update(ctx, req.(*PublisherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublisherController_ServiceDesc is the grpc.ServiceDesc for PublisherController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublisherController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dsg_example.example_bib_app.PublisherController",
	HandlerType: (*PublisherControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PublisherController_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _PublisherController_Destroy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PublisherController_List_Handler,
		},
		{
			MethodName: "PartialUpdate",
			Handler:    _PublisherController_PartialUpdate_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _PublisherController_Retrieve_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PublisherController_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/socio_bib_example_grpc/v1/example_bib_app.proto",
}
